/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@layerzerolabs";
exports.ids = ["vendor-chunks/@layerzerolabs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/node_modules/base-x/src/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@layerzerolabs/lz-v2-utilities/node_modules/base-x/src/index.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxheWVyemVyb2xhYnMvbHotdjItdXRpbGl0aWVzL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJDQUEyQztBQUMzQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVksU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3doYWxlLWJyaWRnZS8uL25vZGVfbW9kdWxlcy9AbGF5ZXJ6ZXJvbGFicy9sei12Mi11dGlsaXRpZXMvbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanM/MTE4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpXG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApXG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJykgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGlcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1NikgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSkgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSlcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHZhciBwYmVnaW4gPSAwXG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKytcbiAgICAgIHplcm9lcysrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwXG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dXG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDBcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBiZWdpbisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrK1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpXG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBuZXcgVWludDhBcnJheSgpIH1cbiAgICB2YXIgcHN6ID0gMFxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrK1xuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2UyNTYgcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUikgKyAxKSA+Pj4gMCAvLyBsb2coNTgpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXAuXG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbc291cmNlLmNoYXJDb2RlQXQocHN6KV1cbiAgICAgICAgICAgIC8vIEludmFsaWQgY2hhcmFjdGVyXG4gICAgICBpZiAoY2FycnkgPT09IDI1NSkgeyByZXR1cm4gfVxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDBcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYjI1Ni5cbiAgICB2YXIgaXQ0ID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrK1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKVxuICAgIHZhciBqID0gemVyb2VzXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXVxuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZylcbiAgICBpZiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2UnICsgQkFTRSArICcgY2hhcmFjdGVyJylcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/node_modules/bs58/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@layerzerolabs/lz-v2-utilities/node_modules/bs58/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/node_modules/base-x/src/index.js\")\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxheWVyemVyb2xhYnMvbHotdjItdXRpbGl0aWVzL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxvR0FBUTtBQUM5Qjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3doYWxlLWJyaWRnZS8uL25vZGVfbW9kdWxlcy9AbGF5ZXJ6ZXJvbGFicy9sei12Mi11dGlsaXRpZXMvbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/YTAyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiYXNleCA9IHJlcXVpcmUoJ2Jhc2UteCcpXG5jb25zdCBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2V4KEFMUEhBQkVUKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/dist/index.cjs":
/*!********************************************************************!*\
  !*** ./node_modules/@layerzerolabs/lz-v2-utilities/dist/index.cjs ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar address = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\nvar bytes = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\nvar base58 = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/node_modules/bs58/index.js\");\nvar abi = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar solidity = __webpack_require__(/*! @ethersproject/solidity */ \"(ssr)/./node_modules/@ethersproject/solidity/lib.esm/index.js\");\nvar invariant = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\");\nvar keccak256 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }\n\nvar base58__default = /*#__PURE__*/_interopDefault(base58);\nvar invariant__default = /*#__PURE__*/_interopDefault(invariant);\n\n// src/utils/hex.ts\nfunction hexZeroPadTo32(addr) {\n  return bytes.hexZeroPad(addr, 32);\n}\nfunction bytes32ToEthAddress(bytes32) {\n  if (bytes32 instanceof Uint8Array) {\n    bytes32 = bytes.hexlify(bytes32);\n  }\n  return address.getAddress(bytes32.slice(-40));\n}\nfunction trim0x(str) {\n  return str.replace(/^0x/, \"\");\n}\nfunction addressToBytes32(address) {\n  if (isSolanaAddress(address)) {\n    return base58__default.default.decode(address);\n  } else if (address.startsWith(\"0x\") && address.length <= 66) {\n    return bytes.arrayify(hexZeroPadTo32(address));\n  }\n  throw new Error(\"Invalid address\");\n}\nvar solanaAddressRegex = /^([1-9A-HJ-NP-Za-km-z]{32,44})$/;\nfunction isSolanaAddress(address) {\n  return solanaAddressRegex.test(address);\n}\n\n// src/utils/precrime.ts\nvar CONFIG_VERSION_OFFSET = 0;\nvar MAX_BATCH_SIZE_OFFSET = 2;\nvar NUMBER_OF_PEERS_OFFSET = 10;\nvar PEERS_OFFSET = 12;\nfunction parsePrecrimeConfig(precrimeConfig) {\n  const data = trim0x(precrimeConfig);\n  const version = parseInt(data.slice(0, 4), 16);\n  if (version === 1) {\n    return parsePrecrimeConfigV1(precrimeConfig);\n  } else if (version === 2) {\n    return parsePrecrimeConfigV2(precrimeConfig);\n  }\n  throw new Error(`Unsupported precrime config version: ${version}`);\n}\nfunction parsePrecrimeConfigV1(precrimeConfig) {\n  const data = trim0x(precrimeConfig);\n  const version = parseInt(data.slice(0, 4), 16);\n  const maxBatchSize = parseInt(data.slice(4, 20), 16);\n  const remoteChainsLength = parseInt(data.slice(20, 84), 16);\n  const remoteChainsBytes = data.slice(84, 84 + remoteChainsLength * 64);\n  const remoteAddressesBytes = data.slice(\n    84 + remoteChainsLength * 64,\n    84 + remoteChainsLength * 64 + remoteChainsLength * 64\n  );\n  const remoteChainsBytesArray = [];\n  const remoteAddressesBytesArray = [];\n  let start = 0;\n  let end = 64;\n  for (let i = 0; i < remoteChainsLength; i++) {\n    remoteChainsBytesArray.push(parseInt(remoteChainsBytes.slice(start, end), 16));\n    remoteAddressesBytesArray.push(`0x${remoteAddressesBytes.slice(start, end)}`);\n    start += 64;\n    end += 64;\n  }\n  return { version, maxBatchSize, remoteEids: remoteChainsBytesArray, remoteAddresses: remoteAddressesBytesArray };\n}\nfunction parsePrecrimeConfigV2(precrimeConfig) {\n  const buffer = Buffer.from(trim0x(precrimeConfig), \"hex\");\n  const version = buffer.readUInt16BE(CONFIG_VERSION_OFFSET);\n  const maxBatchSize = buffer.readBigUint64BE(MAX_BATCH_SIZE_OFFSET);\n  const peers = new Array();\n  if (buffer.length > NUMBER_OF_PEERS_OFFSET) {\n    const numOfPeers = buffer.readUInt16BE(NUMBER_OF_PEERS_OFFSET);\n    for (let i = 0; i < numOfPeers; i++) {\n      const offset = PEERS_OFFSET + i * (4 + 2 * 32);\n      const eid = buffer.readUInt32BE(offset);\n      const preCrimeAddress = \"0x\" + buffer.slice(offset + 4, offset + 4 + 32).toString(\"hex\");\n      const oappAddress = \"0x\" + buffer.slice(offset + 4 + 32, offset + 4 + 32 + 32).toString(\"hex\");\n      peers.push({\n        eid,\n        preCrimeAddress,\n        oappAddress\n      });\n    }\n  }\n  return {\n    version,\n    maxBatchSize,\n    peers\n  };\n}\nvar parseError = (errorData, intf) => {\n  const buildInError = parseBuildInError(errorData);\n  if (buildInError !== void 0) {\n    return buildInError;\n  }\n  if (intf) {\n    try {\n      return intf.parseError(errorData);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n};\nfunction parseBuildInError(errorData) {\n  if (errorData.startsWith(\"0x08c379a0\")) {\n    const content = `0x${errorData.substring(10)}`;\n    const reason = abi.defaultAbiCoder.decode([\"string\"], content);\n    return reason[0];\n  }\n  if (errorData.startsWith(\"0x4e487b71\")) {\n    const content = `0x${errorData.substring(10)}`;\n    const code = abi.defaultAbiCoder.decode([\"uint\"], content);\n    return code[0];\n  }\n  if (errorData === \"0x\") {\n    return \"\";\n  }\n  return void 0;\n}\nvar OptionType = /* @__PURE__ */ ((OptionType2) => {\n  OptionType2[OptionType2[\"TYPE_1\"] = 1] = \"TYPE_1\";\n  OptionType2[OptionType2[\"TYPE_2\"] = 2] = \"TYPE_2\";\n  OptionType2[OptionType2[\"TYPE_3\"] = 3] = \"TYPE_3\";\n  return OptionType2;\n})(OptionType || {});\nvar MAX_UINT_128 = bignumber.BigNumber.from(\"0xffffffffffffffffffffffffffffffff\");\nfunction optionsType1(_extraGas) {\n  const extraGas = bignumber.BigNumber.from(_extraGas);\n  invariant__default.default(extraGas.lte(MAX_UINT_128), \"extraGas should be less than MAX_UINT_128\");\n  return solidity.pack([\"uint16\", \"uint256\"], [1 /* TYPE_1 */, extraGas]);\n}\nfunction optionsType2(_extraGas, _dstNativeAmt, _dstNativeAddress) {\n  const extraGas = bignumber.BigNumber.from(_extraGas);\n  invariant__default.default(extraGas.lte(MAX_UINT_128), \"extraGas should be less than MAX_UINT_128\");\n  const dstNativeAmt = bignumber.BigNumber.from(_dstNativeAmt);\n  invariant__default.default(dstNativeAmt.lte(MAX_UINT_128), \"dstNativeAmt should be less than MAX_UINT_128\");\n  return solidity.pack(\n    [\"uint16\", \"uint256\", \"uint256\", \"bytes\"],\n    [2 /* TYPE_2 */, bignumber.BigNumber.from(extraGas), bignumber.BigNumber.from(dstNativeAmt), _dstNativeAddress]\n  );\n}\nvar WorkerId = /* @__PURE__ */ ((WorkerId2) => {\n  WorkerId2[WorkerId2[\"EXECUTOR\"] = 1] = \"EXECUTOR\";\n  WorkerId2[WorkerId2[\"VERIFIER\"] = 2] = \"VERIFIER\";\n  WorkerId2[WorkerId2[\"TREASURY\"] = 255] = \"TREASURY\";\n  return WorkerId2;\n})(WorkerId || {});\nvar ExecutorOptionType = /* @__PURE__ */ ((ExecutorOptionType2) => {\n  ExecutorOptionType2[ExecutorOptionType2[\"LZ_RECEIVE\"] = 1] = \"LZ_RECEIVE\";\n  ExecutorOptionType2[ExecutorOptionType2[\"NATIVE_DROP\"] = 2] = \"NATIVE_DROP\";\n  ExecutorOptionType2[ExecutorOptionType2[\"COMPOSE\"] = 3] = \"COMPOSE\";\n  ExecutorOptionType2[ExecutorOptionType2[\"ORDERED\"] = 4] = \"ORDERED\";\n  return ExecutorOptionType2;\n})(ExecutorOptionType || {});\nvar VerifierOptionType = /* @__PURE__ */ ((VerifierOptionType2) => {\n  VerifierOptionType2[VerifierOptionType2[\"PRECRIME\"] = 1] = \"PRECRIME\";\n  return VerifierOptionType2;\n})(VerifierOptionType || {});\nvar Options = class _Options {\n  workerOptions = [];\n  // dissuade public instantiation\n  constructor() {\n  }\n  /**\n   * Create a new options instance.\n   */\n  static newOptions() {\n    return new _Options();\n  }\n  /**\n   * Create an options instance from a hex string.\n   * @param {string} optionsHex The hex string to decode.\n   */\n  static fromOptions(optionsHex) {\n    const options = new _Options();\n    const optionsBytes = bytes.arrayify(optionsHex);\n    const optionsType = bignumber.BigNumber.from(optionsBytes.slice(0, 2)).toNumber();\n    if (optionsType === 3 /* TYPE_3 */) {\n      let cursor = 2;\n      while (cursor < optionsBytes.byteLength) {\n        const workerId = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();\n        cursor += 1;\n        const size = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 2)).toNumber();\n        cursor += 2;\n        if (workerId === 1 /* EXECUTOR */) {\n          const optionType = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();\n          cursor += 1;\n          const params = optionsBytes.slice(cursor, cursor + size - 1);\n          cursor += size - 1;\n          options.addOption(workerId, { type: optionType, params: bytes.hexlify(params) });\n        } else if (workerId === 2 /* VERIFIER */) {\n          const verifierIdx = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();\n          cursor += 1;\n          const optionType = bignumber.BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber();\n          cursor += 1;\n          const params = optionsBytes.slice(cursor, cursor + size - 2);\n          cursor += size - 2;\n          const option = {\n            type: optionType,\n            index: verifierIdx,\n            params: bytes.hexlify(params)\n          };\n          options.addOption(workerId, option);\n        }\n      }\n    } else if (optionsType === 2 /* TYPE_2 */) {\n      const extraGas = bignumber.BigNumber.from(optionsBytes.slice(2, 34)).toBigInt();\n      const dstNativeAmt = bignumber.BigNumber.from(optionsBytes.slice(34, 66)).toBigInt();\n      const dstNativeAddress = bytes.hexlify(optionsBytes.slice(66, optionsBytes.byteLength));\n      options.addExecutorLzReceiveOption(extraGas).addExecutorNativeDropOption(dstNativeAmt, dstNativeAddress);\n    } else if (optionsType === 1 /* TYPE_1 */) {\n      const extraGas = bignumber.BigNumber.from(optionsBytes.slice(2, 34)).toBigInt();\n      options.addExecutorLzReceiveOption(extraGas);\n    }\n    return options;\n  }\n  /**\n   * Add ExecutorOptionType.LZ_RECEIVE option.\n   * @param {GasLimit} gasLimit\n   * @param {NativeDrop} nativeDrop\n   */\n  addExecutorLzReceiveOption(gasLimit, nativeDrop = 0) {\n    const gasLimitBN = bignumber.BigNumber.from(gasLimit);\n    invariant__default.default(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\");\n    const nativeDropBN = bignumber.BigNumber.from(nativeDrop);\n    invariant__default.default(nativeDropBN.lte(MAX_UINT_128), \"value shouldn't be greater than MAX_UINT_128\");\n    this.addOption(1 /* EXECUTOR */, {\n      type: 1 /* LZ_RECEIVE */,\n      params: nativeDropBN.eq(0) ? solidity.pack([\"uint128\"], [gasLimitBN]) : solidity.pack([\"uint128\", \"uint128\"], [gasLimitBN, nativeDropBN])\n    });\n    return this;\n  }\n  /**\n   * Add ExecutorOptionType.NATIVE_DROP option.\n   * @param {NativeDrop} nativeDrop\n   * @param {string} receiver\n   */\n  addExecutorNativeDropOption(nativeDrop, receiver) {\n    const amountBN = bignumber.BigNumber.from(nativeDrop);\n    invariant__default.default(amountBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\");\n    this.addOption(1 /* EXECUTOR */, {\n      type: 2 /* NATIVE_DROP */,\n      params: solidity.pack([\"uint128\", \"bytes32\"], [amountBN, addressToBytes32(receiver)])\n    });\n    return this;\n  }\n  /**\n   * Add ExecutorOptionType.COMPOSE option.\n   * @param {number} index\n   * @param {GasLimit} gasLimit\n   * @param {NativeDrop} nativeDrop\n   */\n  addExecutorComposeOption(index, gasLimit, nativeDrop = 0) {\n    const gasLimitBN = bignumber.BigNumber.from(gasLimit);\n    invariant__default.default(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\");\n    const nativeDropBN = bignumber.BigNumber.from(nativeDrop);\n    invariant__default.default(nativeDropBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\");\n    const option = nativeDropBN.gt(0) ? {\n      type: 3 /* COMPOSE */,\n      params: solidity.pack([\"uint16\", \"uint128\", \"uint128\"], [index, gasLimitBN, nativeDropBN])\n    } : {\n      type: 3 /* COMPOSE */,\n      params: solidity.pack([\"uint16\", \"uint128\"], [index, gasLimitBN])\n    };\n    this.addOption(1 /* EXECUTOR */, option);\n    return this;\n  }\n  /**\n   * Add ExecutorOptionType.ORDERED option.\n   */\n  addExecutorOrderedExecutionOption() {\n    this.addOption(1 /* EXECUTOR */, {\n      type: 4 /* ORDERED */,\n      params: \"0x\"\n    });\n    return this;\n  }\n  /**\n   * Add VerifierOptionType.PRECRIME option.\n   * @param {number} verifierIdx\n   */\n  addVerifierPrecrimeOption(verifierIdx) {\n    const option = {\n      type: 1 /* PRECRIME */,\n      index: verifierIdx,\n      params: \"0x\"\n    };\n    this.addOption(2 /* VERIFIER */, option);\n    return this;\n  }\n  /**\n   * Serialize Options to hex string.\n   */\n  toHex() {\n    let hex = solidity.pack([\"uint16\"], [3 /* TYPE_3 */]);\n    this.workerOptions.forEach((w) => {\n      for (const option of w.options) {\n        if (w.workerId === 1 /* EXECUTOR */) {\n          hex += trim0x(\n            solidity.pack(\n              [\"uint8\", \"uint16\", \"uint8\", \"bytes\"],\n              [w.workerId, trim0x(option.params).length / 2 + 1, option.type, option.params]\n            )\n          );\n        } else if (w.workerId === 2 /* VERIFIER */) {\n          const verifierOption = option;\n          hex += trim0x(\n            solidity.pack(\n              [\"uint8\", \"uint16\", \"uint8\", \"uint8\", \"bytes\"],\n              [\n                w.workerId,\n                trim0x(option.params).length / 2 + 2,\n                verifierOption.index,\n                verifierOption.type,\n                verifierOption.params\n              ]\n            )\n          );\n        }\n      }\n    });\n    return hex;\n  }\n  /**\n   * Serialize Options to Uint8Array.\n   */\n  toBytes() {\n    return bytes.arrayify(this.toHex());\n  }\n  addOption(workerId, option) {\n    const worker = this.workerOptions.find((w) => w.workerId === workerId);\n    if (worker) {\n      worker.options.push(option);\n    } else {\n      this.workerOptions.push({ workerId, options: [option] });\n    }\n  }\n  /**\n   * Decode ExecutorOptionType.LZ_RECEIVE option.  Returns undefined if the option is not present.\n   */\n  decodeExecutorLzReceiveOption() {\n    let options = this.findOptions(1 /* EXECUTOR */, 1 /* LZ_RECEIVE */);\n    if (options === void 0 || Array.isArray(options) && options.length === 0) {\n      return;\n    }\n    let totalGas = bignumber.BigNumber.from(0).toBigInt();\n    let totalValue = bignumber.BigNumber.from(0).toBigInt();\n    options = Array.isArray(options) ? options : [options];\n    for (const option of options) {\n      const buffer = Buffer.from(trim0x(option.params), \"hex\");\n      const gas = bignumber.BigNumber.from(buffer.subarray(0, 16)).toBigInt();\n      const value = bignumber.BigNumber.from(buffer.length === 16 ? 0 : buffer.subarray(16, 32)).toBigInt();\n      totalGas = totalGas + gas;\n      totalValue = totalValue + value;\n    }\n    return { gas: totalGas, value: totalValue };\n  }\n  /**\n   * Decode ExecutorOptionType.NATIVE_DROP options.  Returns undefined if the options is not present.\n   */\n  decodeExecutorNativeDropOption() {\n    const options = this.findOptions(1 /* EXECUTOR */, 2 /* NATIVE_DROP */);\n    if (!options || options.length === 0) {\n      return [];\n    }\n    const results = options.reduce((acc, cur) => {\n      const buffer = Buffer.from(trim0x(cur.params), \"hex\");\n      const amount = bignumber.BigNumber.from(buffer.subarray(0, 16)).toBigInt();\n      const receiver = bytes.hexlify(buffer.subarray(16, 48));\n      if (acc[receiver]) {\n        acc[receiver].amount = acc[receiver].amount + amount;\n      } else {\n        acc[receiver] = { amount, receiver };\n      }\n      return acc;\n    }, {});\n    return Object.values(results);\n  }\n  /**\n   * Decode ExecutorOptionType.COMPOSE options.  Returns undefined if the options is not present.\n   */\n  decodeExecutorComposeOption() {\n    const options = this.findOptions(1 /* EXECUTOR */, 3 /* COMPOSE */);\n    if (!options || options.length === 0) {\n      return [];\n    }\n    const results = options.reduce(\n      (acc, cur) => {\n        const buffer = Buffer.from(trim0x(cur.params), \"hex\");\n        const index = bignumber.BigNumber.from(buffer.subarray(0, 2)).toNumber();\n        const gas = bignumber.BigNumber.from(buffer.subarray(2, 18)).toBigInt();\n        const value = (buffer.length === 34 ? bignumber.BigNumber.from(buffer.subarray(18, 34)) : bignumber.BigNumber.from(0)).toBigInt();\n        if (acc[index]) {\n          acc[index].gas = acc[index].gas + gas;\n          acc[index].value = acc[index].value + value;\n        } else {\n          acc[index] = { index, gas, value };\n        }\n        return acc;\n      },\n      {}\n    );\n    return Object.values(results);\n  }\n  /**\n   * Decode ExecutorOptionType.ORDERED options.  Returns undefined if the options is not present.\n   */\n  decodeExecutorOrderedExecutionOption() {\n    const option = this.findOptions(1 /* EXECUTOR */, 4 /* ORDERED */);\n    return option !== void 0;\n  }\n  findOptions(workerId, optionType) {\n    const worker = this.workerOptions.find((w) => w.workerId === workerId);\n    if (worker) {\n      if (optionType === 4 /* ORDERED */) {\n        return worker.options.find((o) => o.type === optionType);\n      }\n      return worker.options.filter((o) => o.type === optionType);\n    }\n  }\n  /**\n   * Find VerifierOption by verifierIdx and optionType.  Returns undefined if the option is not present.\n   * @param {number} verifierIdx\n   * @param {number} optionType\n   */\n  findVerifierOption(verifierIdx, optionType) {\n    const worker = this.workerOptions.find((w) => w.workerId === 2 /* VERIFIER */);\n    if (worker) {\n      const opt = worker.options.find((o) => o.type === optionType && o.index === verifierIdx);\n      if (opt) {\n        return opt;\n      }\n    }\n  }\n};\n\n// src/model/packet.ts\nfunction packetToMessageOrigin(packet) {\n  return {\n    srcEid: packet.srcEid,\n    sender: packet.sender,\n    nonce: packet.nonce\n  };\n}\nvar PACKET_VERSION_OFFSET = 0;\nvar NONCE_OFFSET = 1;\nvar SRC_CHAIN_OFFSET = 9;\nvar SRC_ADDRESS_OFFSET = 13;\nvar DST_CHAIN_OFFSET = 45;\nvar DST_ADDRESS_OFFSET = 49;\nvar GUID_OFFSET = 81;\nvar MESSAGE_OFFSET = 113;\nvar PacketV1Codec = class _PacketV1Codec {\n  buffer;\n  static from(payloadEncoded) {\n    return new _PacketV1Codec(payloadEncoded);\n  }\n  static fromBytes(payload) {\n    return new _PacketV1Codec(\"0x\" + Buffer.from(payload).toString(\"hex\"));\n  }\n  constructor(payloadEncoded) {\n    this.buffer = Buffer.from(trim0x(payloadEncoded), \"hex\");\n  }\n  /**\n   * encode packet to hex string\n   */\n  static encode(packet) {\n    const buff = this.encodeBytes(packet);\n    return \"0x\" + Buffer.from(buff).toString(\"hex\");\n  }\n  /**\n   * encode packet to Uint8Array\n   * @param packet\n   */\n  static encodeBytes(packet) {\n    const message = trim0x(packet.message);\n    const buffer = Buffer.alloc(MESSAGE_OFFSET + message.length / 2);\n    buffer.writeUInt8(packet.version, PACKET_VERSION_OFFSET);\n    buffer.writeBigUInt64BE(BigInt(packet.nonce), NONCE_OFFSET);\n    buffer.writeUInt32BE(packet.srcEid, SRC_CHAIN_OFFSET);\n    buffer.write(Buffer.from(addressToBytes32(packet.sender)).toString(\"hex\"), SRC_ADDRESS_OFFSET, 32, \"hex\");\n    buffer.writeUInt32BE(packet.dstEid, DST_CHAIN_OFFSET);\n    buffer.write(Buffer.from(addressToBytes32(packet.receiver)).toString(\"hex\"), DST_ADDRESS_OFFSET, 32, \"hex\");\n    buffer.write(trim0x(packet.guid), GUID_OFFSET, 32, \"hex\");\n    buffer.write(message, MESSAGE_OFFSET, message.length / 2, \"hex\");\n    return new Uint8Array(buffer);\n  }\n  version() {\n    return this.buffer.readUInt8(PACKET_VERSION_OFFSET);\n  }\n  nonce() {\n    return this.buffer.readBigUint64BE(NONCE_OFFSET).toString();\n  }\n  srcEid() {\n    return this.buffer.readUint32BE(SRC_CHAIN_OFFSET);\n  }\n  sender() {\n    return \"0x\" + this.buffer.slice(SRC_ADDRESS_OFFSET, DST_CHAIN_OFFSET).toString(\"hex\");\n  }\n  senderAddressB20() {\n    return bytes32ToEthAddress(this.sender());\n  }\n  dstEid() {\n    return this.buffer.readUint32BE(DST_CHAIN_OFFSET);\n  }\n  receiver() {\n    return \"0x\" + this.buffer.slice(DST_ADDRESS_OFFSET, GUID_OFFSET).toString(\"hex\");\n  }\n  receiverAddressB20() {\n    return bytes32ToEthAddress(this.receiver());\n  }\n  guid() {\n    return \"0x\" + this.buffer.slice(GUID_OFFSET, MESSAGE_OFFSET).toString(\"hex\");\n  }\n  message() {\n    return \"0x\" + this.buffer.slice(MESSAGE_OFFSET).toString(\"hex\");\n  }\n  payloadHash() {\n    return keccak256.keccak256(this.payload());\n  }\n  payload() {\n    return \"0x\" + this.buffer.slice(GUID_OFFSET).toString(\"hex\");\n  }\n  header() {\n    return \"0x\" + this.buffer.slice(0, GUID_OFFSET).toString(\"hex\");\n  }\n  headerHash() {\n    return keccak256.keccak256(this.header());\n  }\n  /**\n   * deserialize packet from hex string\n   * @deprecated use toPacket instead\n   */\n  decode() {\n    return this.toPacket();\n  }\n  toPacket() {\n    return {\n      version: this.version(),\n      nonce: this.nonce(),\n      srcEid: this.srcEid(),\n      sender: this.sender(),\n      dstEid: this.dstEid(),\n      receiver: this.receiver(),\n      guid: this.guid(),\n      message: this.message(),\n      // derived\n      payload: this.payload()\n    };\n  }\n};\nfunction calculateGuid(packetHead) {\n  return keccak256.keccak256(\n    solidity.pack(\n      [\"uint64\", \"uint32\", \"bytes32\", \"uint32\", \"bytes32\"],\n      [\n        bignumber.BigNumber.from(packetHead.nonce),\n        packetHead.srcEid,\n        addressToBytes32(packetHead.sender),\n        packetHead.dstEid,\n        addressToBytes32(packetHead.receiver)\n      ]\n    )\n  );\n}\n\n// src/codec/packet-serializer.ts\nvar PacketSerializer = class {\n  static serialize(packet) {\n    return PacketV1Codec.encode(packet);\n  }\n  static serializeBytes(packet) {\n    return PacketV1Codec.encodeBytes(packet);\n  }\n  static deserialize(bytesLike) {\n    let codec;\n    if (bytesLike instanceof Uint8Array) {\n      codec = PacketV1Codec.fromBytes(bytesLike);\n    } else {\n      codec = PacketV1Codec.from(bytesLike);\n    }\n    return codec.toPacket();\n  }\n};\n\nObject.defineProperty(exports, \"keccak256\", ({\n  enumerable: true,\n  get: function () { return keccak256.keccak256; }\n}));\nexports.ExecutorOptionType = ExecutorOptionType;\nexports.OptionType = OptionType;\nexports.Options = Options;\nexports.PacketSerializer = PacketSerializer;\nexports.PacketV1Codec = PacketV1Codec;\nexports.VerifierOptionType = VerifierOptionType;\nexports.WorkerId = WorkerId;\nexports.addressToBytes32 = addressToBytes32;\nexports.bytes32ToEthAddress = bytes32ToEthAddress;\nexports.calculateGuid = calculateGuid;\nexports.hexZeroPadTo32 = hexZeroPadTo32;\nexports.isSolanaAddress = isSolanaAddress;\nexports.optionsType1 = optionsType1;\nexports.optionsType2 = optionsType2;\nexports.packetToMessageOrigin = packetToMessageOrigin;\nexports.parseError = parseError;\nexports.parsePrecrimeConfig = parsePrecrimeConfig;\nexports.trim0x = trim0x;\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxheWVyemVyb2xhYnMvbHotdjItdXRpbGl0aWVzL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDOUMsWUFBWSxtQkFBTyxDQUFDLHdGQUFzQjtBQUMxQyxhQUFhLG1CQUFPLENBQUMsNEZBQU07QUFDM0IsVUFBVSxtQkFBTyxDQUFDLG9GQUFvQjtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyxnR0FBMEI7QUFDbEQsZUFBZSxtQkFBTyxDQUFDLDhGQUF5QjtBQUNoRCxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBZ0I7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsZ0dBQTBCOztBQUVsRCwrQkFBK0IsaUNBQWlDOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0Esd0NBQXdDLHVDQUF1QztBQUMvRTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaURBQWlEO0FBQ3pGLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDO0FBQzVDO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUMsRUFBQztBQUNGLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQix3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0IsY0FBYztBQUNkO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGFsZS1icmlkZ2UvLi9ub2RlX21vZHVsZXMvQGxheWVyemVyb2xhYnMvbHotdjItdXRpbGl0aWVzL2Rpc3QvaW5kZXguY2pzPzY1NGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRkcmVzcyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2FkZHJlc3MnKTtcbnZhciBieXRlcyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2J5dGVzJyk7XG52YXIgYmFzZTU4ID0gcmVxdWlyZSgnYnM1OCcpO1xudmFyIGFiaSA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2FiaScpO1xudmFyIGJpZ251bWJlciA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcicpO1xudmFyIHNvbGlkaXR5ID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3Qvc29saWRpdHknKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCd0aW55LWludmFyaWFudCcpO1xudmFyIGtlY2NhazI1NiA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2tlY2NhazI1NicpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG5cbnZhciBiYXNlNThfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KGJhc2U1OCk7XG52YXIgaW52YXJpYW50X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChpbnZhcmlhbnQpO1xuXG4vLyBzcmMvdXRpbHMvaGV4LnRzXG5mdW5jdGlvbiBoZXhaZXJvUGFkVG8zMihhZGRyKSB7XG4gIHJldHVybiBieXRlcy5oZXhaZXJvUGFkKGFkZHIsIDMyKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzMzJUb0V0aEFkZHJlc3MoYnl0ZXMzMikge1xuICBpZiAoYnl0ZXMzMiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBieXRlczMyID0gYnl0ZXMuaGV4bGlmeShieXRlczMyKTtcbiAgfVxuICByZXR1cm4gYWRkcmVzcy5nZXRBZGRyZXNzKGJ5dGVzMzIuc2xpY2UoLTQwKSk7XG59XG5mdW5jdGlvbiB0cmltMHgoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXjB4LywgXCJcIik7XG59XG5mdW5jdGlvbiBhZGRyZXNzVG9CeXRlczMyKGFkZHJlc3MpIHtcbiAgaWYgKGlzU29sYW5hQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgIHJldHVybiBiYXNlNThfX2RlZmF1bHQuZGVmYXVsdC5kZWNvZGUoYWRkcmVzcyk7XG4gIH0gZWxzZSBpZiAoYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikgJiYgYWRkcmVzcy5sZW5ndGggPD0gNjYpIHtcbiAgICByZXR1cm4gYnl0ZXMuYXJyYXlpZnkoaGV4WmVyb1BhZFRvMzIoYWRkcmVzcykpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYWRkcmVzc1wiKTtcbn1cbnZhciBzb2xhbmFBZGRyZXNzUmVnZXggPSAvXihbMS05QS1ISi1OUC1aYS1rbS16XXszMiw0NH0pJC87XG5mdW5jdGlvbiBpc1NvbGFuYUFkZHJlc3MoYWRkcmVzcykge1xuICByZXR1cm4gc29sYW5hQWRkcmVzc1JlZ2V4LnRlc3QoYWRkcmVzcyk7XG59XG5cbi8vIHNyYy91dGlscy9wcmVjcmltZS50c1xudmFyIENPTkZJR19WRVJTSU9OX09GRlNFVCA9IDA7XG52YXIgTUFYX0JBVENIX1NJWkVfT0ZGU0VUID0gMjtcbnZhciBOVU1CRVJfT0ZfUEVFUlNfT0ZGU0VUID0gMTA7XG52YXIgUEVFUlNfT0ZGU0VUID0gMTI7XG5mdW5jdGlvbiBwYXJzZVByZWNyaW1lQ29uZmlnKHByZWNyaW1lQ29uZmlnKSB7XG4gIGNvbnN0IGRhdGEgPSB0cmltMHgocHJlY3JpbWVDb25maWcpO1xuICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoZGF0YS5zbGljZSgwLCA0KSwgMTYpO1xuICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgIHJldHVybiBwYXJzZVByZWNyaW1lQ29uZmlnVjEocHJlY3JpbWVDb25maWcpO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDIpIHtcbiAgICByZXR1cm4gcGFyc2VQcmVjcmltZUNvbmZpZ1YyKHByZWNyaW1lQ29uZmlnKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHByZWNyaW1lIGNvbmZpZyB2ZXJzaW9uOiAke3ZlcnNpb259YCk7XG59XG5mdW5jdGlvbiBwYXJzZVByZWNyaW1lQ29uZmlnVjEocHJlY3JpbWVDb25maWcpIHtcbiAgY29uc3QgZGF0YSA9IHRyaW0weChwcmVjcmltZUNvbmZpZyk7XG4gIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludChkYXRhLnNsaWNlKDAsIDQpLCAxNik7XG4gIGNvbnN0IG1heEJhdGNoU2l6ZSA9IHBhcnNlSW50KGRhdGEuc2xpY2UoNCwgMjApLCAxNik7XG4gIGNvbnN0IHJlbW90ZUNoYWluc0xlbmd0aCA9IHBhcnNlSW50KGRhdGEuc2xpY2UoMjAsIDg0KSwgMTYpO1xuICBjb25zdCByZW1vdGVDaGFpbnNCeXRlcyA9IGRhdGEuc2xpY2UoODQsIDg0ICsgcmVtb3RlQ2hhaW5zTGVuZ3RoICogNjQpO1xuICBjb25zdCByZW1vdGVBZGRyZXNzZXNCeXRlcyA9IGRhdGEuc2xpY2UoXG4gICAgODQgKyByZW1vdGVDaGFpbnNMZW5ndGggKiA2NCxcbiAgICA4NCArIHJlbW90ZUNoYWluc0xlbmd0aCAqIDY0ICsgcmVtb3RlQ2hhaW5zTGVuZ3RoICogNjRcbiAgKTtcbiAgY29uc3QgcmVtb3RlQ2hhaW5zQnl0ZXNBcnJheSA9IFtdO1xuICBjb25zdCByZW1vdGVBZGRyZXNzZXNCeXRlc0FycmF5ID0gW107XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSA2NDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdGVDaGFpbnNMZW5ndGg7IGkrKykge1xuICAgIHJlbW90ZUNoYWluc0J5dGVzQXJyYXkucHVzaChwYXJzZUludChyZW1vdGVDaGFpbnNCeXRlcy5zbGljZShzdGFydCwgZW5kKSwgMTYpKTtcbiAgICByZW1vdGVBZGRyZXNzZXNCeXRlc0FycmF5LnB1c2goYDB4JHtyZW1vdGVBZGRyZXNzZXNCeXRlcy5zbGljZShzdGFydCwgZW5kKX1gKTtcbiAgICBzdGFydCArPSA2NDtcbiAgICBlbmQgKz0gNjQ7XG4gIH1cbiAgcmV0dXJuIHsgdmVyc2lvbiwgbWF4QmF0Y2hTaXplLCByZW1vdGVFaWRzOiByZW1vdGVDaGFpbnNCeXRlc0FycmF5LCByZW1vdGVBZGRyZXNzZXM6IHJlbW90ZUFkZHJlc3Nlc0J5dGVzQXJyYXkgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJlY3JpbWVDb25maWdWMihwcmVjcmltZUNvbmZpZykge1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbSh0cmltMHgocHJlY3JpbWVDb25maWcpLCBcImhleFwiKTtcbiAgY29uc3QgdmVyc2lvbiA9IGJ1ZmZlci5yZWFkVUludDE2QkUoQ09ORklHX1ZFUlNJT05fT0ZGU0VUKTtcbiAgY29uc3QgbWF4QmF0Y2hTaXplID0gYnVmZmVyLnJlYWRCaWdVaW50NjRCRShNQVhfQkFUQ0hfU0laRV9PRkZTRVQpO1xuICBjb25zdCBwZWVycyA9IG5ldyBBcnJheSgpO1xuICBpZiAoYnVmZmVyLmxlbmd0aCA+IE5VTUJFUl9PRl9QRUVSU19PRkZTRVQpIHtcbiAgICBjb25zdCBudW1PZlBlZXJzID0gYnVmZmVyLnJlYWRVSW50MTZCRShOVU1CRVJfT0ZfUEVFUlNfT0ZGU0VUKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mUGVlcnM7IGkrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gUEVFUlNfT0ZGU0VUICsgaSAqICg0ICsgMiAqIDMyKTtcbiAgICAgIGNvbnN0IGVpZCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgICAgIGNvbnN0IHByZUNyaW1lQWRkcmVzcyA9IFwiMHhcIiArIGJ1ZmZlci5zbGljZShvZmZzZXQgKyA0LCBvZmZzZXQgKyA0ICsgMzIpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgY29uc3Qgb2FwcEFkZHJlc3MgPSBcIjB4XCIgKyBidWZmZXIuc2xpY2Uob2Zmc2V0ICsgNCArIDMyLCBvZmZzZXQgKyA0ICsgMzIgKyAzMikudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICBwZWVycy5wdXNoKHtcbiAgICAgICAgZWlkLFxuICAgICAgICBwcmVDcmltZUFkZHJlc3MsXG4gICAgICAgIG9hcHBBZGRyZXNzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uLFxuICAgIG1heEJhdGNoU2l6ZSxcbiAgICBwZWVyc1xuICB9O1xufVxudmFyIHBhcnNlRXJyb3IgPSAoZXJyb3JEYXRhLCBpbnRmKSA9PiB7XG4gIGNvbnN0IGJ1aWxkSW5FcnJvciA9IHBhcnNlQnVpbGRJbkVycm9yKGVycm9yRGF0YSk7XG4gIGlmIChidWlsZEluRXJyb3IgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBidWlsZEluRXJyb3I7XG4gIH1cbiAgaWYgKGludGYpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGludGYucGFyc2VFcnJvcihlcnJvckRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gcGFyc2VCdWlsZEluRXJyb3IoZXJyb3JEYXRhKSB7XG4gIGlmIChlcnJvckRhdGEuc3RhcnRzV2l0aChcIjB4MDhjMzc5YTBcIikpIHtcbiAgICBjb25zdCBjb250ZW50ID0gYDB4JHtlcnJvckRhdGEuc3Vic3RyaW5nKDEwKX1gO1xuICAgIGNvbnN0IHJlYXNvbiA9IGFiaS5kZWZhdWx0QWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSwgY29udGVudCk7XG4gICAgcmV0dXJuIHJlYXNvblswXTtcbiAgfVxuICBpZiAoZXJyb3JEYXRhLnN0YXJ0c1dpdGgoXCIweDRlNDg3YjcxXCIpKSB7XG4gICAgY29uc3QgY29udGVudCA9IGAweCR7ZXJyb3JEYXRhLnN1YnN0cmluZygxMCl9YDtcbiAgICBjb25zdCBjb2RlID0gYWJpLmRlZmF1bHRBYmlDb2Rlci5kZWNvZGUoW1widWludFwiXSwgY29udGVudCk7XG4gICAgcmV0dXJuIGNvZGVbMF07XG4gIH1cbiAgaWYgKGVycm9yRGF0YSA9PT0gXCIweFwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbnZhciBPcHRpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoT3B0aW9uVHlwZTIpID0+IHtcbiAgT3B0aW9uVHlwZTJbT3B0aW9uVHlwZTJbXCJUWVBFXzFcIl0gPSAxXSA9IFwiVFlQRV8xXCI7XG4gIE9wdGlvblR5cGUyW09wdGlvblR5cGUyW1wiVFlQRV8yXCJdID0gMl0gPSBcIlRZUEVfMlwiO1xuICBPcHRpb25UeXBlMltPcHRpb25UeXBlMltcIlRZUEVfM1wiXSA9IDNdID0gXCJUWVBFXzNcIjtcbiAgcmV0dXJuIE9wdGlvblR5cGUyO1xufSkoT3B0aW9uVHlwZSB8fCB7fSk7XG52YXIgTUFYX1VJTlRfMTI4ID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbmZ1bmN0aW9uIG9wdGlvbnNUeXBlMShfZXh0cmFHYXMpIHtcbiAgY29uc3QgZXh0cmFHYXMgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oX2V4dHJhR2FzKTtcbiAgaW52YXJpYW50X19kZWZhdWx0LmRlZmF1bHQoZXh0cmFHYXMubHRlKE1BWF9VSU5UXzEyOCksIFwiZXh0cmFHYXMgc2hvdWxkIGJlIGxlc3MgdGhhbiBNQVhfVUlOVF8xMjhcIik7XG4gIHJldHVybiBzb2xpZGl0eS5wYWNrKFtcInVpbnQxNlwiLCBcInVpbnQyNTZcIl0sIFsxIC8qIFRZUEVfMSAqLywgZXh0cmFHYXNdKTtcbn1cbmZ1bmN0aW9uIG9wdGlvbnNUeXBlMihfZXh0cmFHYXMsIF9kc3ROYXRpdmVBbXQsIF9kc3ROYXRpdmVBZGRyZXNzKSB7XG4gIGNvbnN0IGV4dHJhR2FzID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKF9leHRyYUdhcyk7XG4gIGludmFyaWFudF9fZGVmYXVsdC5kZWZhdWx0KGV4dHJhR2FzLmx0ZShNQVhfVUlOVF8xMjgpLCBcImV4dHJhR2FzIHNob3VsZCBiZSBsZXNzIHRoYW4gTUFYX1VJTlRfMTI4XCIpO1xuICBjb25zdCBkc3ROYXRpdmVBbXQgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oX2RzdE5hdGl2ZUFtdCk7XG4gIGludmFyaWFudF9fZGVmYXVsdC5kZWZhdWx0KGRzdE5hdGl2ZUFtdC5sdGUoTUFYX1VJTlRfMTI4KSwgXCJkc3ROYXRpdmVBbXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBNQVhfVUlOVF8xMjhcIik7XG4gIHJldHVybiBzb2xpZGl0eS5wYWNrKFxuICAgIFtcInVpbnQxNlwiLCBcInVpbnQyNTZcIiwgXCJ1aW50MjU2XCIsIFwiYnl0ZXNcIl0sXG4gICAgWzIgLyogVFlQRV8yICovLCBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oZXh0cmFHYXMpLCBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oZHN0TmF0aXZlQW10KSwgX2RzdE5hdGl2ZUFkZHJlc3NdXG4gICk7XG59XG52YXIgV29ya2VySWQgPSAvKiBAX19QVVJFX18gKi8gKChXb3JrZXJJZDIpID0+IHtcbiAgV29ya2VySWQyW1dvcmtlcklkMltcIkVYRUNVVE9SXCJdID0gMV0gPSBcIkVYRUNVVE9SXCI7XG4gIFdvcmtlcklkMltXb3JrZXJJZDJbXCJWRVJJRklFUlwiXSA9IDJdID0gXCJWRVJJRklFUlwiO1xuICBXb3JrZXJJZDJbV29ya2VySWQyW1wiVFJFQVNVUllcIl0gPSAyNTVdID0gXCJUUkVBU1VSWVwiO1xuICByZXR1cm4gV29ya2VySWQyO1xufSkoV29ya2VySWQgfHwge30pO1xudmFyIEV4ZWN1dG9yT3B0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV4ZWN1dG9yT3B0aW9uVHlwZTIpID0+IHtcbiAgRXhlY3V0b3JPcHRpb25UeXBlMltFeGVjdXRvck9wdGlvblR5cGUyW1wiTFpfUkVDRUlWRVwiXSA9IDFdID0gXCJMWl9SRUNFSVZFXCI7XG4gIEV4ZWN1dG9yT3B0aW9uVHlwZTJbRXhlY3V0b3JPcHRpb25UeXBlMltcIk5BVElWRV9EUk9QXCJdID0gMl0gPSBcIk5BVElWRV9EUk9QXCI7XG4gIEV4ZWN1dG9yT3B0aW9uVHlwZTJbRXhlY3V0b3JPcHRpb25UeXBlMltcIkNPTVBPU0VcIl0gPSAzXSA9IFwiQ09NUE9TRVwiO1xuICBFeGVjdXRvck9wdGlvblR5cGUyW0V4ZWN1dG9yT3B0aW9uVHlwZTJbXCJPUkRFUkVEXCJdID0gNF0gPSBcIk9SREVSRURcIjtcbiAgcmV0dXJuIEV4ZWN1dG9yT3B0aW9uVHlwZTI7XG59KShFeGVjdXRvck9wdGlvblR5cGUgfHwge30pO1xudmFyIFZlcmlmaWVyT3B0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFZlcmlmaWVyT3B0aW9uVHlwZTIpID0+IHtcbiAgVmVyaWZpZXJPcHRpb25UeXBlMltWZXJpZmllck9wdGlvblR5cGUyW1wiUFJFQ1JJTUVcIl0gPSAxXSA9IFwiUFJFQ1JJTUVcIjtcbiAgcmV0dXJuIFZlcmlmaWVyT3B0aW9uVHlwZTI7XG59KShWZXJpZmllck9wdGlvblR5cGUgfHwge30pO1xudmFyIE9wdGlvbnMgPSBjbGFzcyBfT3B0aW9ucyB7XG4gIHdvcmtlck9wdGlvbnMgPSBbXTtcbiAgLy8gZGlzc3VhZGUgcHVibGljIGluc3RhbnRpYXRpb25cbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIGluc3RhbmNlLlxuICAgKi9cbiAgc3RhdGljIG5ld09wdGlvbnMoKSB7XG4gICAgcmV0dXJuIG5ldyBfT3B0aW9ucygpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gb3B0aW9ucyBpbnN0YW5jZSBmcm9tIGEgaGV4IHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnNIZXggVGhlIGhleCBzdHJpbmcgdG8gZGVjb2RlLlxuICAgKi9cbiAgc3RhdGljIGZyb21PcHRpb25zKG9wdGlvbnNIZXgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gbmV3IF9PcHRpb25zKCk7XG4gICAgY29uc3Qgb3B0aW9uc0J5dGVzID0gYnl0ZXMuYXJyYXlpZnkob3B0aW9uc0hleCk7XG4gICAgY29uc3Qgb3B0aW9uc1R5cGUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ob3B0aW9uc0J5dGVzLnNsaWNlKDAsIDIpKS50b051bWJlcigpO1xuICAgIGlmIChvcHRpb25zVHlwZSA9PT0gMyAvKiBUWVBFXzMgKi8pIHtcbiAgICAgIGxldCBjdXJzb3IgPSAyO1xuICAgICAgd2hpbGUgKGN1cnNvciA8IG9wdGlvbnNCeXRlcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcklkID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKG9wdGlvbnNCeXRlcy5zbGljZShjdXJzb3IsIGN1cnNvciArIDEpKS50b051bWJlcigpO1xuICAgICAgICBjdXJzb3IgKz0gMTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShvcHRpb25zQnl0ZXMuc2xpY2UoY3Vyc29yLCBjdXJzb3IgKyAyKSkudG9OdW1iZXIoKTtcbiAgICAgICAgY3Vyc29yICs9IDI7XG4gICAgICAgIGlmICh3b3JrZXJJZCA9PT0gMSAvKiBFWEVDVVRPUiAqLykge1xuICAgICAgICAgIGNvbnN0IG9wdGlvblR5cGUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ob3B0aW9uc0J5dGVzLnNsaWNlKGN1cnNvciwgY3Vyc29yICsgMSkpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gb3B0aW9uc0J5dGVzLnNsaWNlKGN1cnNvciwgY3Vyc29yICsgc2l6ZSAtIDEpO1xuICAgICAgICAgIGN1cnNvciArPSBzaXplIC0gMTtcbiAgICAgICAgICBvcHRpb25zLmFkZE9wdGlvbih3b3JrZXJJZCwgeyB0eXBlOiBvcHRpb25UeXBlLCBwYXJhbXM6IGJ5dGVzLmhleGxpZnkocGFyYW1zKSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh3b3JrZXJJZCA9PT0gMiAvKiBWRVJJRklFUiAqLykge1xuICAgICAgICAgIGNvbnN0IHZlcmlmaWVySWR4ID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKG9wdGlvbnNCeXRlcy5zbGljZShjdXJzb3IsIGN1cnNvciArIDEpKS50b051bWJlcigpO1xuICAgICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICAgIGNvbnN0IG9wdGlvblR5cGUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ob3B0aW9uc0J5dGVzLnNsaWNlKGN1cnNvciwgY3Vyc29yICsgMSkpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gb3B0aW9uc0J5dGVzLnNsaWNlKGN1cnNvciwgY3Vyc29yICsgc2l6ZSAtIDIpO1xuICAgICAgICAgIGN1cnNvciArPSBzaXplIC0gMjtcbiAgICAgICAgICBjb25zdCBvcHRpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiBvcHRpb25UeXBlLFxuICAgICAgICAgICAgaW5kZXg6IHZlcmlmaWVySWR4LFxuICAgICAgICAgICAgcGFyYW1zOiBieXRlcy5oZXhsaWZ5KHBhcmFtcylcbiAgICAgICAgICB9O1xuICAgICAgICAgIG9wdGlvbnMuYWRkT3B0aW9uKHdvcmtlcklkLCBvcHRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zVHlwZSA9PT0gMiAvKiBUWVBFXzIgKi8pIHtcbiAgICAgIGNvbnN0IGV4dHJhR2FzID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKG9wdGlvbnNCeXRlcy5zbGljZSgyLCAzNCkpLnRvQmlnSW50KCk7XG4gICAgICBjb25zdCBkc3ROYXRpdmVBbXQgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ob3B0aW9uc0J5dGVzLnNsaWNlKDM0LCA2NikpLnRvQmlnSW50KCk7XG4gICAgICBjb25zdCBkc3ROYXRpdmVBZGRyZXNzID0gYnl0ZXMuaGV4bGlmeShvcHRpb25zQnl0ZXMuc2xpY2UoNjYsIG9wdGlvbnNCeXRlcy5ieXRlTGVuZ3RoKSk7XG4gICAgICBvcHRpb25zLmFkZEV4ZWN1dG9yTHpSZWNlaXZlT3B0aW9uKGV4dHJhR2FzKS5hZGRFeGVjdXRvck5hdGl2ZURyb3BPcHRpb24oZHN0TmF0aXZlQW10LCBkc3ROYXRpdmVBZGRyZXNzKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnNUeXBlID09PSAxIC8qIFRZUEVfMSAqLykge1xuICAgICAgY29uc3QgZXh0cmFHYXMgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ob3B0aW9uc0J5dGVzLnNsaWNlKDIsIDM0KSkudG9CaWdJbnQoKTtcbiAgICAgIG9wdGlvbnMuYWRkRXhlY3V0b3JMelJlY2VpdmVPcHRpb24oZXh0cmFHYXMpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogQWRkIEV4ZWN1dG9yT3B0aW9uVHlwZS5MWl9SRUNFSVZFIG9wdGlvbi5cbiAgICogQHBhcmFtIHtHYXNMaW1pdH0gZ2FzTGltaXRcbiAgICogQHBhcmFtIHtOYXRpdmVEcm9wfSBuYXRpdmVEcm9wXG4gICAqL1xuICBhZGRFeGVjdXRvckx6UmVjZWl2ZU9wdGlvbihnYXNMaW1pdCwgbmF0aXZlRHJvcCA9IDApIHtcbiAgICBjb25zdCBnYXNMaW1pdEJOID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGdhc0xpbWl0KTtcbiAgICBpbnZhcmlhbnRfX2RlZmF1bHQuZGVmYXVsdChnYXNMaW1pdEJOLmx0ZShNQVhfVUlOVF8xMjgpLCBcImdhc0xpbWl0IHNob3VsZG4ndCBiZSBncmVhdGVyIHRoYW4gTUFYX1VJTlRfMTI4XCIpO1xuICAgIGNvbnN0IG5hdGl2ZURyb3BCTiA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShuYXRpdmVEcm9wKTtcbiAgICBpbnZhcmlhbnRfX2RlZmF1bHQuZGVmYXVsdChuYXRpdmVEcm9wQk4ubHRlKE1BWF9VSU5UXzEyOCksIFwidmFsdWUgc2hvdWxkbid0IGJlIGdyZWF0ZXIgdGhhbiBNQVhfVUlOVF8xMjhcIik7XG4gICAgdGhpcy5hZGRPcHRpb24oMSAvKiBFWEVDVVRPUiAqLywge1xuICAgICAgdHlwZTogMSAvKiBMWl9SRUNFSVZFICovLFxuICAgICAgcGFyYW1zOiBuYXRpdmVEcm9wQk4uZXEoMCkgPyBzb2xpZGl0eS5wYWNrKFtcInVpbnQxMjhcIl0sIFtnYXNMaW1pdEJOXSkgOiBzb2xpZGl0eS5wYWNrKFtcInVpbnQxMjhcIiwgXCJ1aW50MTI4XCJdLCBbZ2FzTGltaXRCTiwgbmF0aXZlRHJvcEJOXSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkIEV4ZWN1dG9yT3B0aW9uVHlwZS5OQVRJVkVfRFJPUCBvcHRpb24uXG4gICAqIEBwYXJhbSB7TmF0aXZlRHJvcH0gbmF0aXZlRHJvcFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVjZWl2ZXJcbiAgICovXG4gIGFkZEV4ZWN1dG9yTmF0aXZlRHJvcE9wdGlvbihuYXRpdmVEcm9wLCByZWNlaXZlcikge1xuICAgIGNvbnN0IGFtb3VudEJOID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKG5hdGl2ZURyb3ApO1xuICAgIGludmFyaWFudF9fZGVmYXVsdC5kZWZhdWx0KGFtb3VudEJOLmx0ZShNQVhfVUlOVF8xMjgpLCBcIm5hdGl2ZURyb3Agc2hvdWxkbid0IGJlIGdyZWF0ZXIgdGhhbiBNQVhfVUlOVF8xMjhcIik7XG4gICAgdGhpcy5hZGRPcHRpb24oMSAvKiBFWEVDVVRPUiAqLywge1xuICAgICAgdHlwZTogMiAvKiBOQVRJVkVfRFJPUCAqLyxcbiAgICAgIHBhcmFtczogc29saWRpdHkucGFjayhbXCJ1aW50MTI4XCIsIFwiYnl0ZXMzMlwiXSwgW2Ftb3VudEJOLCBhZGRyZXNzVG9CeXRlczMyKHJlY2VpdmVyKV0pXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBFeGVjdXRvck9wdGlvblR5cGUuQ09NUE9TRSBvcHRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge0dhc0xpbWl0fSBnYXNMaW1pdFxuICAgKiBAcGFyYW0ge05hdGl2ZURyb3B9IG5hdGl2ZURyb3BcbiAgICovXG4gIGFkZEV4ZWN1dG9yQ29tcG9zZU9wdGlvbihpbmRleCwgZ2FzTGltaXQsIG5hdGl2ZURyb3AgPSAwKSB7XG4gICAgY29uc3QgZ2FzTGltaXRCTiA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShnYXNMaW1pdCk7XG4gICAgaW52YXJpYW50X19kZWZhdWx0LmRlZmF1bHQoZ2FzTGltaXRCTi5sdGUoTUFYX1VJTlRfMTI4KSwgXCJnYXNMaW1pdCBzaG91bGRuJ3QgYmUgZ3JlYXRlciB0aGFuIE1BWF9VSU5UXzEyOFwiKTtcbiAgICBjb25zdCBuYXRpdmVEcm9wQk4gPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20obmF0aXZlRHJvcCk7XG4gICAgaW52YXJpYW50X19kZWZhdWx0LmRlZmF1bHQobmF0aXZlRHJvcEJOLmx0ZShNQVhfVUlOVF8xMjgpLCBcIm5hdGl2ZURyb3Agc2hvdWxkbid0IGJlIGdyZWF0ZXIgdGhhbiBNQVhfVUlOVF8xMjhcIik7XG4gICAgY29uc3Qgb3B0aW9uID0gbmF0aXZlRHJvcEJOLmd0KDApID8ge1xuICAgICAgdHlwZTogMyAvKiBDT01QT1NFICovLFxuICAgICAgcGFyYW1zOiBzb2xpZGl0eS5wYWNrKFtcInVpbnQxNlwiLCBcInVpbnQxMjhcIiwgXCJ1aW50MTI4XCJdLCBbaW5kZXgsIGdhc0xpbWl0Qk4sIG5hdGl2ZURyb3BCTl0pXG4gICAgfSA6IHtcbiAgICAgIHR5cGU6IDMgLyogQ09NUE9TRSAqLyxcbiAgICAgIHBhcmFtczogc29saWRpdHkucGFjayhbXCJ1aW50MTZcIiwgXCJ1aW50MTI4XCJdLCBbaW5kZXgsIGdhc0xpbWl0Qk5dKVxuICAgIH07XG4gICAgdGhpcy5hZGRPcHRpb24oMSAvKiBFWEVDVVRPUiAqLywgb3B0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkIEV4ZWN1dG9yT3B0aW9uVHlwZS5PUkRFUkVEIG9wdGlvbi5cbiAgICovXG4gIGFkZEV4ZWN1dG9yT3JkZXJlZEV4ZWN1dGlvbk9wdGlvbigpIHtcbiAgICB0aGlzLmFkZE9wdGlvbigxIC8qIEVYRUNVVE9SICovLCB7XG4gICAgICB0eXBlOiA0IC8qIE9SREVSRUQgKi8sXG4gICAgICBwYXJhbXM6IFwiMHhcIlxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgVmVyaWZpZXJPcHRpb25UeXBlLlBSRUNSSU1FIG9wdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZlcmlmaWVySWR4XG4gICAqL1xuICBhZGRWZXJpZmllclByZWNyaW1lT3B0aW9uKHZlcmlmaWVySWR4KSB7XG4gICAgY29uc3Qgb3B0aW9uID0ge1xuICAgICAgdHlwZTogMSAvKiBQUkVDUklNRSAqLyxcbiAgICAgIGluZGV4OiB2ZXJpZmllcklkeCxcbiAgICAgIHBhcmFtczogXCIweFwiXG4gICAgfTtcbiAgICB0aGlzLmFkZE9wdGlvbigyIC8qIFZFUklGSUVSICovLCBvcHRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgT3B0aW9ucyB0byBoZXggc3RyaW5nLlxuICAgKi9cbiAgdG9IZXgoKSB7XG4gICAgbGV0IGhleCA9IHNvbGlkaXR5LnBhY2soW1widWludDE2XCJdLCBbMyAvKiBUWVBFXzMgKi9dKTtcbiAgICB0aGlzLndvcmtlck9wdGlvbnMuZm9yRWFjaCgodykgPT4ge1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygdy5vcHRpb25zKSB7XG4gICAgICAgIGlmICh3LndvcmtlcklkID09PSAxIC8qIEVYRUNVVE9SICovKSB7XG4gICAgICAgICAgaGV4ICs9IHRyaW0weChcbiAgICAgICAgICAgIHNvbGlkaXR5LnBhY2soXG4gICAgICAgICAgICAgIFtcInVpbnQ4XCIsIFwidWludDE2XCIsIFwidWludDhcIiwgXCJieXRlc1wiXSxcbiAgICAgICAgICAgICAgW3cud29ya2VySWQsIHRyaW0weChvcHRpb24ucGFyYW1zKS5sZW5ndGggLyAyICsgMSwgb3B0aW9uLnR5cGUsIG9wdGlvbi5wYXJhbXNdXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh3LndvcmtlcklkID09PSAyIC8qIFZFUklGSUVSICovKSB7XG4gICAgICAgICAgY29uc3QgdmVyaWZpZXJPcHRpb24gPSBvcHRpb247XG4gICAgICAgICAgaGV4ICs9IHRyaW0weChcbiAgICAgICAgICAgIHNvbGlkaXR5LnBhY2soXG4gICAgICAgICAgICAgIFtcInVpbnQ4XCIsIFwidWludDE2XCIsIFwidWludDhcIiwgXCJ1aW50OFwiLCBcImJ5dGVzXCJdLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgdy53b3JrZXJJZCxcbiAgICAgICAgICAgICAgICB0cmltMHgob3B0aW9uLnBhcmFtcykubGVuZ3RoIC8gMiArIDIsXG4gICAgICAgICAgICAgICAgdmVyaWZpZXJPcHRpb24uaW5kZXgsXG4gICAgICAgICAgICAgICAgdmVyaWZpZXJPcHRpb24udHlwZSxcbiAgICAgICAgICAgICAgICB2ZXJpZmllck9wdGlvbi5wYXJhbXNcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGV4O1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgT3B0aW9ucyB0byBVaW50OEFycmF5LlxuICAgKi9cbiAgdG9CeXRlcygpIHtcbiAgICByZXR1cm4gYnl0ZXMuYXJyYXlpZnkodGhpcy50b0hleCgpKTtcbiAgfVxuICBhZGRPcHRpb24od29ya2VySWQsIG9wdGlvbikge1xuICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2VyT3B0aW9ucy5maW5kKCh3KSA9PiB3LndvcmtlcklkID09PSB3b3JrZXJJZCk7XG4gICAgaWYgKHdvcmtlcikge1xuICAgICAgd29ya2VyLm9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmtlck9wdGlvbnMucHVzaCh7IHdvcmtlcklkLCBvcHRpb25zOiBbb3B0aW9uXSB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlY29kZSBFeGVjdXRvck9wdGlvblR5cGUuTFpfUkVDRUlWRSBvcHRpb24uICBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgb3B0aW9uIGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgZGVjb2RlRXhlY3V0b3JMelJlY2VpdmVPcHRpb24oKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLmZpbmRPcHRpb25zKDEgLyogRVhFQ1VUT1IgKi8sIDEgLyogTFpfUkVDRUlWRSAqLyk7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpICYmIG9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0b3RhbEdhcyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSgwKS50b0JpZ0ludCgpO1xuICAgIGxldCB0b3RhbFZhbHVlID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKDApLnRvQmlnSW50KCk7XG4gICAgb3B0aW9ucyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucykgPyBvcHRpb25zIDogW29wdGlvbnNdO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRyaW0weChvcHRpb24ucGFyYW1zKSwgXCJoZXhcIik7XG4gICAgICBjb25zdCBnYXMgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oYnVmZmVyLnN1YmFycmF5KDAsIDE2KSkudG9CaWdJbnQoKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGJ1ZmZlci5sZW5ndGggPT09IDE2ID8gMCA6IGJ1ZmZlci5zdWJhcnJheSgxNiwgMzIpKS50b0JpZ0ludCgpO1xuICAgICAgdG90YWxHYXMgPSB0b3RhbEdhcyArIGdhcztcbiAgICAgIHRvdGFsVmFsdWUgPSB0b3RhbFZhbHVlICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB7IGdhczogdG90YWxHYXMsIHZhbHVlOiB0b3RhbFZhbHVlIH07XG4gIH1cbiAgLyoqXG4gICAqIERlY29kZSBFeGVjdXRvck9wdGlvblR5cGUuTkFUSVZFX0RST1Agb3B0aW9ucy4gIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBvcHRpb25zIGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgZGVjb2RlRXhlY3V0b3JOYXRpdmVEcm9wT3B0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmZpbmRPcHRpb25zKDEgLyogRVhFQ1VUT1IgKi8sIDIgLyogTkFUSVZFX0RST1AgKi8pO1xuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRzID0gb3B0aW9ucy5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbSh0cmltMHgoY3VyLnBhcmFtcyksIFwiaGV4XCIpO1xuICAgICAgY29uc3QgYW1vdW50ID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGJ1ZmZlci5zdWJhcnJheSgwLCAxNikpLnRvQmlnSW50KCk7XG4gICAgICBjb25zdCByZWNlaXZlciA9IGJ5dGVzLmhleGxpZnkoYnVmZmVyLnN1YmFycmF5KDE2LCA0OCkpO1xuICAgICAgaWYgKGFjY1tyZWNlaXZlcl0pIHtcbiAgICAgICAgYWNjW3JlY2VpdmVyXS5hbW91bnQgPSBhY2NbcmVjZWl2ZXJdLmFtb3VudCArIGFtb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjY1tyZWNlaXZlcl0gPSB7IGFtb3VudCwgcmVjZWl2ZXIgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdHMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNvZGUgRXhlY3V0b3JPcHRpb25UeXBlLkNPTVBPU0Ugb3B0aW9ucy4gIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBvcHRpb25zIGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgZGVjb2RlRXhlY3V0b3JDb21wb3NlT3B0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmZpbmRPcHRpb25zKDEgLyogRVhFQ1VUT1IgKi8sIDMgLyogQ09NUE9TRSAqLyk7XG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBvcHRpb25zLnJlZHVjZShcbiAgICAgIChhY2MsIGN1cikgPT4ge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbSh0cmltMHgoY3VyLnBhcmFtcyksIFwiaGV4XCIpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShidWZmZXIuc3ViYXJyYXkoMCwgMikpLnRvTnVtYmVyKCk7XG4gICAgICAgIGNvbnN0IGdhcyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShidWZmZXIuc3ViYXJyYXkoMiwgMTgpKS50b0JpZ0ludCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChidWZmZXIubGVuZ3RoID09PSAzNCA/IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShidWZmZXIuc3ViYXJyYXkoMTgsIDM0KSkgOiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oMCkpLnRvQmlnSW50KCk7XG4gICAgICAgIGlmIChhY2NbaW5kZXhdKSB7XG4gICAgICAgICAgYWNjW2luZGV4XS5nYXMgPSBhY2NbaW5kZXhdLmdhcyArIGdhcztcbiAgICAgICAgICBhY2NbaW5kZXhdLnZhbHVlID0gYWNjW2luZGV4XS52YWx1ZSArIHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY1tpbmRleF0gPSB7IGluZGV4LCBnYXMsIHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICk7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0cyk7XG4gIH1cbiAgLyoqXG4gICAqIERlY29kZSBFeGVjdXRvck9wdGlvblR5cGUuT1JERVJFRCBvcHRpb25zLiAgUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIG9wdGlvbnMgaXMgbm90IHByZXNlbnQuXG4gICAqL1xuICBkZWNvZGVFeGVjdXRvck9yZGVyZWRFeGVjdXRpb25PcHRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gdGhpcy5maW5kT3B0aW9ucygxIC8qIEVYRUNVVE9SICovLCA0IC8qIE9SREVSRUQgKi8pO1xuICAgIHJldHVybiBvcHRpb24gIT09IHZvaWQgMDtcbiAgfVxuICBmaW5kT3B0aW9ucyh3b3JrZXJJZCwgb3B0aW9uVHlwZSkge1xuICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2VyT3B0aW9ucy5maW5kKCh3KSA9PiB3LndvcmtlcklkID09PSB3b3JrZXJJZCk7XG4gICAgaWYgKHdvcmtlcikge1xuICAgICAgaWYgKG9wdGlvblR5cGUgPT09IDQgLyogT1JERVJFRCAqLykge1xuICAgICAgICByZXR1cm4gd29ya2VyLm9wdGlvbnMuZmluZCgobykgPT4gby50eXBlID09PSBvcHRpb25UeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrZXIub3B0aW9ucy5maWx0ZXIoKG8pID0+IG8udHlwZSA9PT0gb3B0aW9uVHlwZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGaW5kIFZlcmlmaWVyT3B0aW9uIGJ5IHZlcmlmaWVySWR4IGFuZCBvcHRpb25UeXBlLiAgUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIG9wdGlvbiBpcyBub3QgcHJlc2VudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZlcmlmaWVySWR4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25UeXBlXG4gICAqL1xuICBmaW5kVmVyaWZpZXJPcHRpb24odmVyaWZpZXJJZHgsIG9wdGlvblR5cGUpIHtcbiAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlck9wdGlvbnMuZmluZCgodykgPT4gdy53b3JrZXJJZCA9PT0gMiAvKiBWRVJJRklFUiAqLyk7XG4gICAgaWYgKHdvcmtlcikge1xuICAgICAgY29uc3Qgb3B0ID0gd29ya2VyLm9wdGlvbnMuZmluZCgobykgPT4gby50eXBlID09PSBvcHRpb25UeXBlICYmIG8uaW5kZXggPT09IHZlcmlmaWVySWR4KTtcbiAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9tb2RlbC9wYWNrZXQudHNcbmZ1bmN0aW9uIHBhY2tldFRvTWVzc2FnZU9yaWdpbihwYWNrZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBzcmNFaWQ6IHBhY2tldC5zcmNFaWQsXG4gICAgc2VuZGVyOiBwYWNrZXQuc2VuZGVyLFxuICAgIG5vbmNlOiBwYWNrZXQubm9uY2VcbiAgfTtcbn1cbnZhciBQQUNLRVRfVkVSU0lPTl9PRkZTRVQgPSAwO1xudmFyIE5PTkNFX09GRlNFVCA9IDE7XG52YXIgU1JDX0NIQUlOX09GRlNFVCA9IDk7XG52YXIgU1JDX0FERFJFU1NfT0ZGU0VUID0gMTM7XG52YXIgRFNUX0NIQUlOX09GRlNFVCA9IDQ1O1xudmFyIERTVF9BRERSRVNTX09GRlNFVCA9IDQ5O1xudmFyIEdVSURfT0ZGU0VUID0gODE7XG52YXIgTUVTU0FHRV9PRkZTRVQgPSAxMTM7XG52YXIgUGFja2V0VjFDb2RlYyA9IGNsYXNzIF9QYWNrZXRWMUNvZGVjIHtcbiAgYnVmZmVyO1xuICBzdGF0aWMgZnJvbShwYXlsb2FkRW5jb2RlZCkge1xuICAgIHJldHVybiBuZXcgX1BhY2tldFYxQ29kZWMocGF5bG9hZEVuY29kZWQpO1xuICB9XG4gIHN0YXRpYyBmcm9tQnl0ZXMocGF5bG9hZCkge1xuICAgIHJldHVybiBuZXcgX1BhY2tldFYxQ29kZWMoXCIweFwiICsgQnVmZmVyLmZyb20ocGF5bG9hZCkudG9TdHJpbmcoXCJoZXhcIikpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBheWxvYWRFbmNvZGVkKSB7XG4gICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuZnJvbSh0cmltMHgocGF5bG9hZEVuY29kZWQpLCBcImhleFwiKTtcbiAgfVxuICAvKipcbiAgICogZW5jb2RlIHBhY2tldCB0byBoZXggc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgZW5jb2RlKHBhY2tldCkge1xuICAgIGNvbnN0IGJ1ZmYgPSB0aGlzLmVuY29kZUJ5dGVzKHBhY2tldCk7XG4gICAgcmV0dXJuIFwiMHhcIiArIEJ1ZmZlci5mcm9tKGJ1ZmYpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIC8qKlxuICAgKiBlbmNvZGUgcGFja2V0IHRvIFVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHBhY2tldFxuICAgKi9cbiAgc3RhdGljIGVuY29kZUJ5dGVzKHBhY2tldCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0cmltMHgocGFja2V0Lm1lc3NhZ2UpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhNRVNTQUdFX09GRlNFVCArIG1lc3NhZ2UubGVuZ3RoIC8gMik7XG4gICAgYnVmZmVyLndyaXRlVUludDgocGFja2V0LnZlcnNpb24sIFBBQ0tFVF9WRVJTSU9OX09GRlNFVCk7XG4gICAgYnVmZmVyLndyaXRlQmlnVUludDY0QkUoQmlnSW50KHBhY2tldC5ub25jZSksIE5PTkNFX09GRlNFVCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUocGFja2V0LnNyY0VpZCwgU1JDX0NIQUlOX09GRlNFVCk7XG4gICAgYnVmZmVyLndyaXRlKEJ1ZmZlci5mcm9tKGFkZHJlc3NUb0J5dGVzMzIocGFja2V0LnNlbmRlcikpLnRvU3RyaW5nKFwiaGV4XCIpLCBTUkNfQUREUkVTU19PRkZTRVQsIDMyLCBcImhleFwiKTtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShwYWNrZXQuZHN0RWlkLCBEU1RfQ0hBSU5fT0ZGU0VUKTtcbiAgICBidWZmZXIud3JpdGUoQnVmZmVyLmZyb20oYWRkcmVzc1RvQnl0ZXMzMihwYWNrZXQucmVjZWl2ZXIpKS50b1N0cmluZyhcImhleFwiKSwgRFNUX0FERFJFU1NfT0ZGU0VULCAzMiwgXCJoZXhcIik7XG4gICAgYnVmZmVyLndyaXRlKHRyaW0weChwYWNrZXQuZ3VpZCksIEdVSURfT0ZGU0VULCAzMiwgXCJoZXhcIik7XG4gICAgYnVmZmVyLndyaXRlKG1lc3NhZ2UsIE1FU1NBR0VfT0ZGU0VULCBtZXNzYWdlLmxlbmd0aCAvIDIsIFwiaGV4XCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICB9XG4gIHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnJlYWRVSW50OChQQUNLRVRfVkVSU0lPTl9PRkZTRVQpO1xuICB9XG4gIG5vbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkQmlnVWludDY0QkUoTk9OQ0VfT0ZGU0VUKS50b1N0cmluZygpO1xuICB9XG4gIHNyY0VpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIucmVhZFVpbnQzMkJFKFNSQ19DSEFJTl9PRkZTRVQpO1xuICB9XG4gIHNlbmRlcigpIHtcbiAgICByZXR1cm4gXCIweFwiICsgdGhpcy5idWZmZXIuc2xpY2UoU1JDX0FERFJFU1NfT0ZGU0VULCBEU1RfQ0hBSU5fT0ZGU0VUKS50b1N0cmluZyhcImhleFwiKTtcbiAgfVxuICBzZW5kZXJBZGRyZXNzQjIwKCkge1xuICAgIHJldHVybiBieXRlczMyVG9FdGhBZGRyZXNzKHRoaXMuc2VuZGVyKCkpO1xuICB9XG4gIGRzdEVpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIucmVhZFVpbnQzMkJFKERTVF9DSEFJTl9PRkZTRVQpO1xuICB9XG4gIHJlY2VpdmVyKCkge1xuICAgIHJldHVybiBcIjB4XCIgKyB0aGlzLmJ1ZmZlci5zbGljZShEU1RfQUREUkVTU19PRkZTRVQsIEdVSURfT0ZGU0VUKS50b1N0cmluZyhcImhleFwiKTtcbiAgfVxuICByZWNlaXZlckFkZHJlc3NCMjAoKSB7XG4gICAgcmV0dXJuIGJ5dGVzMzJUb0V0aEFkZHJlc3ModGhpcy5yZWNlaXZlcigpKTtcbiAgfVxuICBndWlkKCkge1xuICAgIHJldHVybiBcIjB4XCIgKyB0aGlzLmJ1ZmZlci5zbGljZShHVUlEX09GRlNFVCwgTUVTU0FHRV9PRkZTRVQpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIHRoaXMuYnVmZmVyLnNsaWNlKE1FU1NBR0VfT0ZGU0VUKS50b1N0cmluZyhcImhleFwiKTtcbiAgfVxuICBwYXlsb2FkSGFzaCgpIHtcbiAgICByZXR1cm4ga2VjY2FrMjU2LmtlY2NhazI1Nih0aGlzLnBheWxvYWQoKSk7XG4gIH1cbiAgcGF5bG9hZCgpIHtcbiAgICByZXR1cm4gXCIweFwiICsgdGhpcy5idWZmZXIuc2xpY2UoR1VJRF9PRkZTRVQpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIGhlYWRlcigpIHtcbiAgICByZXR1cm4gXCIweFwiICsgdGhpcy5idWZmZXIuc2xpY2UoMCwgR1VJRF9PRkZTRVQpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIGhlYWRlckhhc2goKSB7XG4gICAgcmV0dXJuIGtlY2NhazI1Ni5rZWNjYWsyNTYodGhpcy5oZWFkZXIoKSk7XG4gIH1cbiAgLyoqXG4gICAqIGRlc2VyaWFsaXplIHBhY2tldCBmcm9tIGhleCBzdHJpbmdcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHRvUGFja2V0IGluc3RlYWRcbiAgICovXG4gIGRlY29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b1BhY2tldCgpO1xuICB9XG4gIHRvUGFja2V0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24oKSxcbiAgICAgIG5vbmNlOiB0aGlzLm5vbmNlKCksXG4gICAgICBzcmNFaWQ6IHRoaXMuc3JjRWlkKCksXG4gICAgICBzZW5kZXI6IHRoaXMuc2VuZGVyKCksXG4gICAgICBkc3RFaWQ6IHRoaXMuZHN0RWlkKCksXG4gICAgICByZWNlaXZlcjogdGhpcy5yZWNlaXZlcigpLFxuICAgICAgZ3VpZDogdGhpcy5ndWlkKCksXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UoKSxcbiAgICAgIC8vIGRlcml2ZWRcbiAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCgpXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZUd1aWQocGFja2V0SGVhZCkge1xuICByZXR1cm4ga2VjY2FrMjU2LmtlY2NhazI1NihcbiAgICBzb2xpZGl0eS5wYWNrKFxuICAgICAgW1widWludDY0XCIsIFwidWludDMyXCIsIFwiYnl0ZXMzMlwiLCBcInVpbnQzMlwiLCBcImJ5dGVzMzJcIl0sXG4gICAgICBbXG4gICAgICAgIGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShwYWNrZXRIZWFkLm5vbmNlKSxcbiAgICAgICAgcGFja2V0SGVhZC5zcmNFaWQsXG4gICAgICAgIGFkZHJlc3NUb0J5dGVzMzIocGFja2V0SGVhZC5zZW5kZXIpLFxuICAgICAgICBwYWNrZXRIZWFkLmRzdEVpZCxcbiAgICAgICAgYWRkcmVzc1RvQnl0ZXMzMihwYWNrZXRIZWFkLnJlY2VpdmVyKVxuICAgICAgXVxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL2NvZGVjL3BhY2tldC1zZXJpYWxpemVyLnRzXG52YXIgUGFja2V0U2VyaWFsaXplciA9IGNsYXNzIHtcbiAgc3RhdGljIHNlcmlhbGl6ZShwYWNrZXQpIHtcbiAgICByZXR1cm4gUGFja2V0VjFDb2RlYy5lbmNvZGUocGFja2V0KTtcbiAgfVxuICBzdGF0aWMgc2VyaWFsaXplQnl0ZXMocGFja2V0KSB7XG4gICAgcmV0dXJuIFBhY2tldFYxQ29kZWMuZW5jb2RlQnl0ZXMocGFja2V0KTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoYnl0ZXNMaWtlKSB7XG4gICAgbGV0IGNvZGVjO1xuICAgIGlmIChieXRlc0xpa2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBjb2RlYyA9IFBhY2tldFYxQ29kZWMuZnJvbUJ5dGVzKGJ5dGVzTGlrZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVjID0gUGFja2V0VjFDb2RlYy5mcm9tKGJ5dGVzTGlrZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlYy50b1BhY2tldCgpO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJrZWNjYWsyNTZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtlY2NhazI1Ni5rZWNjYWsyNTY7IH1cbn0pO1xuZXhwb3J0cy5FeGVjdXRvck9wdGlvblR5cGUgPSBFeGVjdXRvck9wdGlvblR5cGU7XG5leHBvcnRzLk9wdGlvblR5cGUgPSBPcHRpb25UeXBlO1xuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcbmV4cG9ydHMuUGFja2V0U2VyaWFsaXplciA9IFBhY2tldFNlcmlhbGl6ZXI7XG5leHBvcnRzLlBhY2tldFYxQ29kZWMgPSBQYWNrZXRWMUNvZGVjO1xuZXhwb3J0cy5WZXJpZmllck9wdGlvblR5cGUgPSBWZXJpZmllck9wdGlvblR5cGU7XG5leHBvcnRzLldvcmtlcklkID0gV29ya2VySWQ7XG5leHBvcnRzLmFkZHJlc3NUb0J5dGVzMzIgPSBhZGRyZXNzVG9CeXRlczMyO1xuZXhwb3J0cy5ieXRlczMyVG9FdGhBZGRyZXNzID0gYnl0ZXMzMlRvRXRoQWRkcmVzcztcbmV4cG9ydHMuY2FsY3VsYXRlR3VpZCA9IGNhbGN1bGF0ZUd1aWQ7XG5leHBvcnRzLmhleFplcm9QYWRUbzMyID0gaGV4WmVyb1BhZFRvMzI7XG5leHBvcnRzLmlzU29sYW5hQWRkcmVzcyA9IGlzU29sYW5hQWRkcmVzcztcbmV4cG9ydHMub3B0aW9uc1R5cGUxID0gb3B0aW9uc1R5cGUxO1xuZXhwb3J0cy5vcHRpb25zVHlwZTIgPSBvcHRpb25zVHlwZTI7XG5leHBvcnRzLnBhY2tldFRvTWVzc2FnZU9yaWdpbiA9IHBhY2tldFRvTWVzc2FnZU9yaWdpbjtcbmV4cG9ydHMucGFyc2VFcnJvciA9IHBhcnNlRXJyb3I7XG5leHBvcnRzLnBhcnNlUHJlY3JpbWVDb25maWcgPSBwYXJzZVByZWNyaW1lQ29uZmlnO1xuZXhwb3J0cy50cmltMHggPSB0cmltMHg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXQuanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@layerzerolabs/lz-v2-utilities/dist/index.cjs\n");

/***/ })

};
;